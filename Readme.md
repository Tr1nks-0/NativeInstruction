0. Создаем класс обертку нативных методов с объявлением этих методов:
    ```java
    package com.tr1nks;
    
    public class MyNative {
        public native void voidMethod();
    
        public static native void staticVoidMethod();
    
        public native int intMethod(int a);
    
        public static native int staticIntMethod(int a);
    
        public native String stringMethod(String a);
    
        public static native String staticStringMethod(String a);
    
        public native int[] intArrayMethod(int[] arr);
    
        public static native int[] staticIntArrayMethod(int[] arr);
    
        public native String stringArrayMethod(String[] arr);
    
        public static native String staticStringArrayMethod(String[] arr);
    }
    ```
0. Переходим в консоли в корневой пакет (отмеченный как Sources Root):
    ```bash
    cd src\main\java
    ```
0. Создаем заголовочный файл для С утилитой `javah`, указав в качестве параметра полное имя класса (с пакетом):
    ```bash
    javah com.tr1nks.MyNative 
    ```
    Будет создан файл `.h` :
   ```cpp
   /* DO NOT EDIT THIS FILE - it is machine generated */
   #include <jni.h>
   /* Header for class com_tr1nks_MyNative */
   
   #ifndef _Included_com_tr1nks_MyNative
   #define _Included_com_tr1nks_MyNative
   #ifdef __cplusplus
   extern "C" {
   #endif
   JNIEXPORT void JNICALL Java_com_tr1nks_MyNative_voidMethod
     (JNIEnv *, jobject);
   
   JNIEXPORT void JNICALL Java_com_tr1nks_MyNative_staticVoidMethod
     (JNIEnv *, jclass);
   
   JNIEXPORT jint JNICALL Java_com_tr1nks_MyNative_intMethod
     (JNIEnv *, jobject, jint);
   
   JNIEXPORT jint JNICALL Java_com_tr1nks_MyNative_staticIntMethod
     (JNIEnv *, jclass, jint);
   
   JNIEXPORT jstring JNICALL Java_com_tr1nks_MyNative_stringMethod
     (JNIEnv *, jobject, jstring);
   
   JNIEXPORT jstring JNICALL Java_com_tr1nks_MyNative_staticStringMethod
     (JNIEnv *, jclass, jstring);
   
   JNIEXPORT jintArray JNICALL Java_com_tr1nks_MyNative_intArrayMethod
     (JNIEnv *, jobject, jintArray);
   
   JNIEXPORT jintArray JNICALL Java_com_tr1nks_MyNative_staticIntArrayMethod
     (JNIEnv *, jclass, jintArray);
   
   JNIEXPORT jstring JNICALL Java_com_tr1nks_MyNative_stringArrayMethod
     (JNIEnv *, jobject, jobjectArray);
   
   JNIEXPORT jstring JNICALL Java_com_tr1nks_MyNative_staticStringArrayMethod
     (JNIEnv *, jclass, jobjectArray);
   
   #ifdef __cplusplus
   }
   #endif
   #endif
   ```
0. Создаем проект для реализации нативных методов на С и перемещаем туда заголовочный файл (файл можно переименовать)
0. Создаем файл реализации `implementation.cpp`;
 Копируем из заголовочного файла объявления методов , добавляем  имена параметров, и реализацию методов:
    ```cpp
    #include <iostream>
    #include "start.h"
    
    JNIEXPORT void JNICALL Java_com_tr1nks_MyNative_voidMethod(JNIEnv *env, jobject obj) {
        std::cout << "native" << std::endl;
    }
    
    JNIEXPORT void JNICALL Java_com_tr1nks_MyNative_staticVoidMethod(JNIEnv *env, jclass jcl) {
        std::cout << "static native" << std::endl;
    }
    
    JNIEXPORT jint JNICALL Java_com_tr1nks_MyNative_intMethod(JNIEnv *env, jobject jobj, jint jin) {
        std::cout << "int native -" << jin << std::endl;
        return 2;
    }
    
    JNIEXPORT jint JNICALL Java_com_tr1nks_MyNative_staticIntMethod(JNIEnv *env, jclass jcl, jint jin) {
        std::cout << "static int native -" << jin << std::endl;
        return 3;
    }
    
    JNIEXPORT jstring JNICALL Java_com_tr1nks_MyNative_stringMethod(JNIEnv *env, jobject jobj, jstring jstr) {
    
    }
    
    JNIEXPORT jstring JNICALL Java_com_tr1nks_MyNative_staticStringMethod(JNIEnv *env, jclass jcl, jstring jstr) {
    
    }
    
    JNIEXPORT jintArray JNICALL Java_com_tr1nks_MyNative_intArrayMethod(JNIEnv *env, jobject jobj, jintArray jintarr) {
    
    }
    
    JNIEXPORT jintArray JNICALL Java_com_tr1nks_MyNative_staticIntArrayMethod(JNIEnv *env, jclass jcl, jintArray jintarr) {
    
    }
    
    JNIEXPORT jstring JNICALL Java_com_tr1nks_MyNative_stringArrayMethod(JNIEnv *env, jobject jobj, jobjectArray jobjarr) {
    
    }
    
    JNIEXPORT jstring JNICALL Java_com_tr1nks_MyNative_staticStringArrayMethod(JNIEnv *env, jclass jcl, jobjectArray jobjarr) {
    
    }
    ```
0. Правим файл CMakeLists.txt, добавляем импорт `jni.h` файла и связанных, добавляем в `SOURCE_FILES` все файлы задействованные в построении библиотеки, корректируем имя библиотеки:
    ```txt
       cmake_minimum_required(VERSION 3.9)
       project(Cpart)
       
       set(CMAKE_CXX_STANDARD 17)
       
       find_package(JNI REQUIRED)
       
       include_directories(${JNI_INCLUDE_DIRS})
       
       link_directories(${JAVA_JVM_LIBRARY})
       
       set(SOURCE_FILES
               start.h
               implementation.cpp
               )
       add_library(clib SHARED ${SOURCE_FILES})
    ```
0. Собираем библиотеку и помещаем ее в ресурсы проекта java
0. указываем, перед вызовом нативного метода или в статическом блоке, загрузить библиотеку с помощью класса утилиты `JarResourcesUtil`:
    ```java
    JarResourcesUtil.unpackLoadLib("libclib");
    ```
0. Класс утилита `JarResourcesUtil`:
```java
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URISyntaxException;

public class JarResourcesUtil {

    private static final String RESOURCES_DIR_NAME = File.separator + "res" + File.separator;
    private static final String LIB_RESOURCES_DIR_NAME = File.separator + "lib" + File.separator;
    private static File unpackedResourceDir;
    private static OsType currentOs;

    /**
     * загрузить библиотеку
     * загружает библиотеку если она была ранее распакована, если не была то распакует и загрузит
     *
     * @param libName имя библиотеки (без расширения)
     */
    public static void unpackLoadLib(String libName) {
        String extLibName = libName + currentOs().getLibExtens();
        checkUnpackedResourceDir();
        File unpLibFile = new File(unpackedResourceDir.getPath() + LIB_RESOURCES_DIR_NAME + extLibName);
        if (!unpLibFile.exists()) {
            unpack(extLibName, unpLibFile);
        }
        System.load(unpLibFile.getAbsolutePath());
    }

    /**
     * распаковать ресурс
     * распакует ресурс в директорию ресурсов рядом с jar сохранив структуру директорий ресурса в проекте
     *
     * @param resName имя ресурса
     * @return файл распакованного ресурса
     */
    public static File unpack(String resName) {
        resName = resName.replace("\\", "/");
        if (!resName.startsWith("/")) {
            resName = "/" + resName;
        }
        checkUnpackedResourceDir();
        String unpFilePath = unpackedResourceDir.getPath() + File.separator;
        unpFilePath += resName.substring(1, resName.length()).replace("/", File.separator);
        System.out.println(unpFilePath);
        return unpack(resName, new File(unpFilePath));
    }

    /**
     * распаковать ресурс в указанный файл
     *
     * @param resName имя ресурса внутри jar
     * @param unpFile файл в который будет произведена распаковка
     * @return файл в который был распакован ресурс (unpFile)
     */
    public static File unpack(String resName, File unpFile) {
        new File(unpFile.getParent()).mkdirs();
        InputStream inputStream = null;
        FileOutputStream outputStream = null;
        try {
            inputStream = JarResourcesUtil.class.getResourceAsStream("/" + resName);
            outputStream = new FileOutputStream(unpFile);
            int read;
            byte[] buffer = new byte[1024];
            while ((read = inputStream.read(buffer)) != -1) {
                outputStream.write(buffer, 0, read);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (null != inputStream) {
                    inputStream.close();
                }
                if (null != outputStream) {
                    outputStream.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return unpFile;
    }

    /**
     * проверяет на наличие или создает директорию ресурсов рядом с jar архивом
     */
    private static void checkUnpackedResourceDir() {
        if (null == unpackedResourceDir) {
            try {
                unpackedResourceDir = new File(new File(JarResourcesUtil.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath()).getParentFile().getPath() + RESOURCES_DIR_NAME);
                unpackedResourceDir.mkdirs();
            } catch (URISyntaxException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * получить тип текущей системы
     *
     * @return тип текущей системы
     */
    private static OsType currentOs() {
        if (null == currentOs) {
            String osName = System.getProperty("os.name").toLowerCase();
            if (osName.contains("win")) {
                currentOs = OsType.WIN;
            } else if (osName.contains("nix") || osName.contains("nux") || osName.contains("aix")) {
                currentOs = OsType.UNIX;
            } else if (osName.contains("mac")) {
                currentOs = OsType.MAC;
            } else {
                currentOs = null;
            }
        }
        return currentOs;
    }
}

/**
 * Тип операционной системы на которой сейчас запущен этот jar
 */
enum OsType {
    WIN(".dll"),
    UNIX(".so"),
    MAC(".dylib");
    private final String libExtens;

    /**
     * @param libExtens расширение библиотеки для конкретной системы
     */
    OsType(String libExtens) {
        this.libExtens = libExtens;
    }

    /**
     * получить расширение библиотек этой системы
     *
     * @return расширение библиотек (. включительно если необходима)
     */
    public String getLibExtens() {
        return libExtens;
    }
}
```